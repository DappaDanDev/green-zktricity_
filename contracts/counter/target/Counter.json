{
  "name": "Counter",
  "functions": [
    {
      "name": "compute_note_hash_and_nullifier",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "contract_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "storage_slot",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "preimage",
          "type": {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "headstart",
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 120
          },
          "visibility": "private"
        },
        {
          "name": "owner",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "get_counter",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "owner",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "field"
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "increment",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "owner",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "events": [],
  "debug": {
    "debugSymbols": [
      "eJzt3d+K7ch1x/F3Odcm7PW3luZVQi5M4oDBOCH2nZl3jwyzu20kH81QdVpfSXUVB3afvWoV/aslTX+kv3370//85+//+sf/+fNfvv30t2+vf1u+/fTvf/v2l//9/Z///v//5a+//7+/fvvp9btvf/jzf63/9+ffffvvP/7pD99+kp9/t/mUuqT98sn1f7f28Wl/7Xx8/cD7w6/Pf9j85//43VqHvCiFCKUQpRRilEKcUkhQCklKIY1SSFEKoSSrUpJVKcmqlGRVSrIqJVmVkqxKSValJKtSklUpyWqUZDVKsholWY2SrEZJVqMkq1GS1SjJapRkNUqyOiVZnZKsTklWpySrU5LVKcnqlGR1SrI6JVmdkqxBSdagJGtQkjUoyRqUZA1KsgYlWYOSrEFJ1qAka1KSNSnJmpRkTUqyJiVZk5KsSUnWpCRrUpI1KcnaKMnaKMnaKMnaKMnaKMnaKMnaKMnaKMnaKMnaKMlalGQtSrIWJVmLkqxFSdaiJGtRkrUoyVqUZC1Ksi6UZF0oybpQknWhJOtCSdaFkqwLJVkXSrIulGRdKMkqL0q0youSrfKihKu8KOkqL0q8youSr/KiBKy8KAkrL0rEyguTsSCOhclYDsjiiCwOyeKYLA7K4qgsDsvCuCzBwCzByCzB0CzB2CzB4CzB6CzB8CzB+CzBAC3BCC3BEC3BGC3BIC3BKC3BMC3BOC3BQC3BSC3BUC3BWC3BYC3BaC3BcC3BeC3BgC3BiC3BkC3BmC3BoC3BqC3BsC3BuC3BwC3ByC3B0C3B2C3B4C3B6C3B8C3B+C3BAC7BCC7BEC7BGC7BIC7BKC7BMC7BOC7BQC7BSC7BUC7BWC7BYC7BaC7BcC7BeC7BgC7BiC7BkC7BmC7BoC7BqC7BsC7BuC7BwC7ByC7B0C7B2C7B4C7B6C7B8C7B+C7BAC/BCC/BEC/BGC/BIC/BKC/BMC/BOC/FOC/FOC/FOC/FOC99UTJWMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc5LMc7LMM7LMM7LMM7LMM7LXpSMNYzzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzMozzcozzcozzcozzcozz8hclYx3jvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvBzjvALjvALjvALjvALjvOJFydjAOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/AOK/A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WDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLhWDLlWDLlWDLlWDLlWDJ9YdJWOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZZMOZbMOJbMOJbMOJbMOJbMXpi0NY4lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lM44lc44lc44lc44lc44l8xcmbZ1jyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyZxjyYJjyYJjyYJjyYJjyeKFSdvgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLkWLLkWLLkWLLkWLJ8YdI2OZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZYsOZascSxZ41iyxrFkjWPJ2guTto1j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cpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeIbPzCpmdV8jsvEJm5xVfKmdsyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/NKmZ1Xyuy8UmbnlTI7r/xSOWNTZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfJ7LxKZudVMjuvktl51ZfKGVsyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvIbMzmvI7LyGzM5ryOy8xpfKGTtkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XlNm5zVldl5TZuc1ZXZe80vljJ0yO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7r5bZebXMzqtldl4ts/PqL5UztmV2Xi2z82qZnVfL7LxaZufVMjuvltl5tczOq2V2Xi2z82qZnVfL7LxaZufVMjuvltl5tczOq2V2Xi2z82qZnVfL7LxaZufVMjuvltl5tczOq2V2Xi2z82qZnVfL7LxaZufVMjuvltl5tczOq2V2Xi2z82qZnVfL7LxaZufVMjuvltl5tczOq2V2Xi2z82qZnVfL7LxaZufVMjuvltl5tczOq2V2Xi2z82qZnVfL7LxaZufVMjuvltl5tczOq2V2Xi2z82qZnVfL7LxaZufVMjuvltl5tczOq2V2Xi2z82qZnVfL7LxaZufVMjuvltl5tczOq2V2Xi2z82qZnVfL7LxaZufVMjuvltl5tczOq2V2Xi2z82qZnVfL7LxaZufVMjuvltl5tczOq2V2Xi2z82qZnVfL7LxaZufVMjuvltl5LZmd15LZeS2ZndeS2XmtL5UzdsnsvJbMzmvJ7LyWzM5ryey8lszOa8nsvJbMzmvJ7LyWzM5ryey8lszOa8nsvJbMzmvJ7LyWzM5ryey8lszOa8nsvJbMzmvJ7LyWzM5ryey8lszOa8nsvJbMzmvJ7LzW93Ze+7/l7ztxy+/dybfO2I/eybfO2I/eybfO2I/eybfO2I/eybfO2I/eybfO2I/eybfO2E/eyfd2Xh+9k2+dsR+9E5kz9ns7r4/eicwZ+72d10fvROaM/d7O66N3InPGfm/n9ck7+d7O66N3InPGfm/n9dE7kTljv7fz+uidyJyx39t5ffROZM7Y7+28PnonMmfs93ZeH70TmTP2ezuvj96JzBn7vZ3XR+9E5oz93s7ro3cic8Z+b+f10TuROWO/t/P66J3InLHf23l99E5kztjv7bw+eicyZ+z3dl4fvROZM/Z7O6+P3onMGfu9nddH70TmjP3ezuujdyJzxn5v5/XRO5E5Y7+38/roncicsd/beX30TmTO2O/tvD56JzJn7Pd2Xh+9E5kz9ns7r4/eicwZ+72d10fvROaM/d7O66N3onLG2tf3hl6fvRWVU3bfisoxu29F5Zzdt6Jy0O5bUTlp962oHLX7VlTO2n0rKoftvhWd0/Z7k6/P3orOafu90ddnb0XntP3e7Ouzt6Jz2n5v+PXZW9E5bb83/frsreictt8bf332VnRO2+/Nvz57Kzqn7fcGYJ+9FZ3T9nsTsM/eis5p+70R2GdvRee0/d4M7LO3onPaygzB9q3onLYyU7B9KzqnrcwYbN+KzmkrMwfbt6Jz2soMwvat6Jy2MpOwfSs6p63MKGzfis5pKzML27eic9rKDMP2reictjLTsH0rOqetzDhs34rOaSszD9u3onPaygzE9q3onLYyE7F9KzqnrcxIbN+KzmkrMxPbt6Jz2soMxfat6Jy2MlOxfSs6p63MWGzfis5pKzMX27eic9rKDMb2reictjKTsX0rOqetzGhs34rOaSszG9u3onPaygzH9q3onLYy07F9Kzqnrcx4bN+KzmkrMx/bt6Jz2soMyPat6Jy2MhOyfSs6p63MiGzfis5pKzMj27eic9rKDMn2reictjJTsn0rMqet6WzJTGdLZjpbMtPZktmXzGlrOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlcZ0vmOlsy19mSuc6WzL9kTlvX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnSxY6W7LQ2ZKFzpYsdLZk8SVz2obOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstDZkoXOlix0tmShsyULnS1Z6GzJQmdLFjpbstTZkqXOlix1tmSpsyXLL5nTNnW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSpc6WLHW2ZKmzJUudLVnqbMlSZ0uWOluy1NmSlc6WrHS2ZKWzJSudLVl9yZy2pbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpasdLZkpbMlK50tWelsyUpnS1Y6W7LS2ZKVzpZs6GzJhs6WbOhsyYbOlmx8yZy2Q2dLNnS2ZENnSzZ0tmRDZ0s2dLZkQ2dLNnS2ZENnSzZ0tmRDZ0s2dLZkQ2dLNnS2ZENnSzZ0tmRDZ0s2dLZkQ2dLNnS2ZENnSzZ0tmRDZ0s2dLZkQ2dLNnS2ZENnSzZ0tmRDZ0s2dLZkQ2dLNnS2ZENnSzZ0tmRDZ0s2dLZkQ2dLNnS2ZENnSzZ0tmRDZ0s2dLZkQ2dLNnS2ZENnSzZ0tmRDZ0s2dLZkQ2dLNnS2ZENnSzZ0tmRDZ0s2dLZkQ2dLNnS2ZENnSzZ0tmRDZ0s2dLZkQ2dLNnS2ZENnSzZ0tmRDZ0s2dLZkQ2dLNnS2ZENnSzZ0tmRDZ0s2dLZkQ2dLNnS2ZENnSzZ0tmRDZ0s2dLZkQ2dLNnS2ZENnSzZ0tmRDZ0s2dLZkQ2dLNnS2ZENnSzZ0tmRDZ0s2dLZkQ2dLNnS2ZENnSzZ0tmRDZ0s2dbZkU2dLNnW2ZFNnSza/ZE7bqbMlmzpbsqmzJZs6W7KpsyWbOluyqbMlmzpbsqmzJZs6W7KpsyWbOluyqbMlmzpbsqmzJZs6W7KpsyWbOluyqbMlmzpbsqmzJZs6W7KpsyWbOluyqbMlmzpbsqmzJZs6W7KpsyWbOluyqbMlmzpbsqmzJZs6W7KpsyWbOluyqbMlmzpbsqmzJZs6W7KpsyWbOluyqbMlmzpbsqmzJZs6W7KpsyWbOluy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LurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXLeSihVy0kIsWctFCLlrIRQu5aCEXLeSihVy0kIsWctFCLlrIRQu5aCEXLeSihVy0kIsWctFCLlrIRQu5aCEXLeSihVy0kIsWctFCLlrIRQu5aCEXLeSihVy0kIsWctFCLlrIRQu5aCEXrbM6Zqy/pjK/TqnjT/6aOv7kr6njT/6aOv7kr6njT/6aOv7kb6mzOl5Tx6fymjo+ldfUuRv9K7X/uj+lzt24pc7duKXO3bilzt24pc7duKXO3bikzup4TZ27cUudu3FLoW6c1fGaQt04q+M1hbpxVsdrCnXjrI7X1K0b4X+f+pf/9S8S//rrH3W3v/1R+32BW42+fYFb4759gVs5v32BW4+/fYFb5b99gdvT8e0L3B6kb1/g9sx99wJn+P3kBX76ST5z8icv8NNP8hmpP3mBn36Sz/T9yQv89JN8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NJGLJnLRRC6ayEUTuWgiF03kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi46kIsO5KIDuehALjqQiw7kogO56EAuOpCLDuSiA7noQC46kIsO5KIDuehALjqQiw7kogO56EAuOpCLDuSiA7noQC46kIsO5KIDuehALjrO6jgq/poaNU6p40/+mjr+NGbbX1NzrVPq+NO4po4/jVvqrHN/S/XXMXX8Gfb4nVp+Sh1/htfUsb3X1LG919Tx93VNHX9f19Tx99Xhv1NxSh1PtmvqeLLdUmedu6bO3bilzt24pc7duKXO3bilzt24pc7duKVQN846d02hbpx17ppC3Tjr3DWFunHWuWsKdeOsc9cU6sZZ564p1I2zzl1TqBtnnbumUDfOOndNoW6cde6aQt0469w1hbpx1rlrCnXjrHPXFOrGWeeuKdSNs85dU6gbZ527plA3zjp3TaFunHXumkLdOOvcNYW6cda5awp146xz1xTpxjzr3DVFujHPOndNkW7Ms85dU6Qb86xz1xTpxjzr3DWFunHWuWsKdeOsc9cU6sZZ564p1I2zzl1TqBtnnbumUDfOOndNoW6cde6aQt0469w1hbpx1rlrCnXj/NXiNYW6cf5q8ZpC3Tj74TWFunH+avGaQt04W+U1hbpx/mrxmkLdOLvoNYW68eCitxTqxoOL3lKoGw8uekuhbiAXnchFJ3LRiVx0IhedyEUnctGJXHQiF53IRSdy0YlcdCIXnchFJ3LRiVx0IhedyEUnctGJXHQiF53IRSdy0YlcdCIXnchFJ3LRiVx0IhedyEUnctGJXHQiF53IRSdy0YlcdCIXnchFJ3LRiVx0IhedyEUnctGJXHQiF53IRSdy0YlcdCIXnchFJ3LRiVy0kYs2ctFGLtrIRRu5aCMXbeSijVy0kYs2ctFGLtrIRRu5aCMXbeSijVy0kYs2ctFGLtrIRRu5aCMXbeSijVy0kYs2ctFGLtrIRRu5aCMXbeSijVy0kYs2ctFGLtrIRRu5aCMXbeSijVy0kYs2ctFGLtrIRRu5aCMXbeSijVy0kYs2ctFGLtrIRRu5aCMXbeSijVy0kYs2ctFGLtrIRRu5aCMXbeSijVy0kYs2ctFGLtrIRRu5aCMXbeSijVy0kYs2ctFGLtrIRRu5aCMXbeSijVy0kYs2ctFGLtrIRRu5aCMXbeSijVy0kYs2ctFGLtrIRRu5aCMXbeSijVy0kYs2ctFGLtrIRRdy0YVcdCEXXchFF3LRhVx0IRddyEUXctGFXHQhF13IRRdy0YVcdCEXXchFF3LRhVx0IRddyEUXctGFXHQhF13IRRdy0YVcdCEXXchFF3LRhVx0IRddyEUXctGFXHQhF13IRRdy0YVcdCEXXchFF3LRhVx0IRddyEUXctGFXHQhF13IRRdy0YVcdCEXXchFF3LRhVx0IRddyEUXctGFXHQhF13IRRdy0YVcdCEXXchFF3LRhVx0IRddyEUXctGFXHQhF13IRRdy0YVcdCEXXchFF3LRhVx0IRddyEUXctGFXHQhF13IRRdy0YVcdCEXXchFF3LRhVx0IRddyEUXctGFXHQhF13IRRdy0YVcdCEXXcRF64u46E6BbuwU6MZOgW7sFOjGToFu7BToxk6BbuwU6MZOoW4QF90p1A3iojuFukFcdKdQN4iL7hTqBnHRnULdIC66U6gbxEV3CnWDuOhOoW4QF90p1A3iojuFukFcdKdQN4iL7hTqBnHRnULdIC66U6gbxEV3CnWDuOhOoW4QF90p1A3iojuFukFcdKdQN4iL7hTqBnHRnULdIC66U6gbxEV3CnWDuOhOoW4QF90p1A3iojuFukFcdKdQN4iL7hTqBnHRnULdIC66U6gbxEV3CnWDuOhOoW4QF90p1A3iojuFukFcdKdQN4iL7hTqBnHRnULdIC66U6gbxEV3CnWDuOhOoW4QF90p1A3iojuFukFcdKdQN4iL7hTqBnHRnSLdMOSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0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"
    ],
    "fileMap": {
      "1": {
        "source": "contract Counter {\n    use dep::aztec::{\n        context::{PrivateContext, Context},\n        note::{\n            note_header::NoteHeader,\n            utils as note_utils,\n        },\n        state_vars::map::Map,\n    };\n    use dep::value_note::{\n            balance_utils,\n            value_note::{\n                ValueNoteMethods,\n                VALUE_NOTE_LEN,\n            },\n    };\n    use dep::easy_private_state::easy_private_state::EasyPrivateUint;\n\n    struct Storage {\n        counters: Map<EasyPrivateUint>,\n    }\n    impl Storage {\n        fn init(context: Context) -> pub Self {\n            Storage {\n                counters: Map::new(\n                    context,\n                    1,\n                    |context, slot| {\n                        EasyPrivateUint::new(context, slot)\n                    },\n                ),\n            }\n        }\n    }\n\n    #[aztec(private)]\n    fn constructor(headstart: u120, owner: Field) {\n        let counters = storage.counters;\n        counters.at(owner).add(headstart, owner);\n    }\n\n    #[aztec(private)]\n      fn increment(owner: Field)  {\n        let counters = storage.counters;\n        counters.at(owner).add(1, owner);\n    }\n\n    unconstrained fn compute_note_hash_and_nullifier(\n    contract_address: Field,\n    nonce: Field,\n    storage_slot: Field,\n    preimage: [Field; VALUE_NOTE_LEN],\n    ) -> [Field; 4] {\n    let note_header = NoteHeader::new(contract_address, nonce, storage_slot);\n    note_utils::compute_note_hash_and_nullifier(ValueNoteMethods, note_header, preimage)\n    }\n\n    unconstrained fn get_counter(owner: Field) -> Field {\n    let counters = storage.counters;\n    balance_utils::get_balance(counters.at(owner).set)\n    }\n\n\n}",
        "path": "/home/user/Documents/GitHub/green-zktricity/green-zktricity/green-zktricity/contracts/counter/src/main.nr"
      },
      "18": {
        "source": "struct GrumpkinScalar {\n    low: Field,\n    high: Field,\n}\n\nimpl GrumpkinScalar {\n    pub fn new(low: Field, high: Field) -> Self {\n        // TODO: check that the low and high value fit within the grumpkin modulus\n        GrumpkinScalar { low, high }\n    }\n}\n\nglobal GRUMPKIN_SCALAR_SERIALIZED_LEN: Field = 2;\n\npub fn deserialize_grumpkin_scalar(fields: [Field; GRUMPKIN_SCALAR_SERIALIZED_LEN]) -> GrumpkinScalar {\n    GrumpkinScalar { low: fields[0], high: fields[1] }\n}\n\npub fn serialize_grumpkin_scalar(scalar: GrumpkinScalar) -> [Field; GRUMPKIN_SCALAR_SERIALIZED_LEN] {\n    [scalar.low, scalar.high]\n}\n",
        "path": "std/grumpkin_scalar.nr"
      },
      "19": {
        "source": "use crate::grumpkin_scalar::GrumpkinScalar;\nuse crate::scalar_mul::fixed_base_embedded_curve;\n\npub fn grumpkin_fixed_base(scalar: GrumpkinScalar) -> [Field; 2] {\n    // TODO: this should use both the low and high limbs to do the scalar multiplication\n    fixed_base_embedded_curve(scalar.low, scalar.high)\n}\n",
        "path": "std/grumpkin_scalar_mul.nr"
      },
      "34": {
        "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n",
        "path": "std/option.nr"
      },
      "37": {
        "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    HISTORIC_BLOCK_DATA_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\nuse crate::hash::pedersen_hash;\n\n// docs:start:private-global-variables\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n// docs:end:private-global-variables\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\n// docs:start:public-global-variables\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n// docs:end:public-global-variables\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\n// docs:start:contract-deployment-data\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n// docs:end:contract-deployment-data\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\n// docs:start:private-context-inputs\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    private_global_variables: PrivateGlobalVariables,\n}\n// docs:end:private-context-inputs\n\n// PublicContextInputs are expected to be provided to each public function\n// docs:start:public-context-inputs\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_data: HistoricBlockData,\n\n    public_global_variables: PublicGlobalVariables,\n}\n// docs:end:public-context-inputs\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n    function_selector: Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.function_selector,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\n// docs:start:historic-block-data\nstruct HistoricBlockData {\n    note_hash_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n// docs:end:historic-block-data\n\nimpl HistoricBlockData {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    pub fn serialize(self) -> [Field; HISTORIC_BLOCK_DATA_LENGTH] {\n        [\n            self.note_hash_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    pub fn empty() -> Self {\n        Self { note_hash_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    pending_read_requests: [Field; crate::abi::MAX_PENDING_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        pedersen_hash(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    pub fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_data.serialize());\n        inputs.push(self.prover_address);\n\n        pedersen_hash(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    pub fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hasher {\n    pub fn new()-> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n\n    pub fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n",
        "path": "/aztec/abi.nr"
      },
      "38": {
        "source": "use crate::constants_gen::GENERATOR_INDEX__CONTRACT_ADDRESS;\nuse crate::hash::pedersen_hash;\n\npub fn compute_address(pub_key_x: Field, pub_key_y: Field, partial_address: Field) -> Field {\n  pedersen_hash([pub_key_x, pub_key_y, partial_address], GENERATOR_INDEX__CONTRACT_ADDRESS)\n}",
        "path": "/aztec/address.nr"
      },
      "40": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\nuse dep::std::option::Option;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n    pending_read_requests: BoundedVec<Field, MAX_PENDING_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n            pending_read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            pending_read_requests: self.pending_read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    pub fn push_pending_read_request(&mut self, pending_read_request: Field) {\n        self.pending_read_requests.push(pending_read_request);\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    // We never push a zero nullified_commitment as zero is used to indicate the end\n    // of a field array in private kernel. This routine transparently replaces a\n    // zero value into the special placeholder: EMPTY_NULLIFIED_COMMITMENT.\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        let mut non_zero_nullified = nullified_commitment;\n        if (non_zero_nullified == 0) {\n            non_zero_nullified = EMPTY_NULLIFIED_COMMITMENT;\n        }\n        self.nullified_commitments.push(non_zero_nullified);\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, content: Field) \n    // docs:end:context_message_portal\n    {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        msg_key: Field,\n        content: Field,\n        secret: Field\n    ) \n    // docs:end:context_consume_l1_to_l2_message\n    {\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, self.this_address(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[12],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 13),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 17),\n                pending_read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 49),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 81),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 97),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 113),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 129),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 133),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 137),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 139),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 141),\n                encrypted_log_preimages_length: fields[143],\n                unencrypted_log_preimages_length: fields[144],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    note_hash_tree_root : fields[145],\n                    nullifier_tree_root : fields[146],\n                    contract_tree_root : fields[147],\n                    l1_to_l2_messages_tree_root : fields[148],\n                    blocks_tree_root : fields[149],\n                    public_data_tree_root: fields[150],\n                    global_variables_hash: fields[151],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[152], fields[153]),\n                    constructor_vk_hash : fields[154],\n                    function_tree_root : fields[155],\n                    contract_address_salt : fields[156],\n                    portal_contract_address : fields[157],\n                },\n                chain_id: fields[158],\n                version: fields[159],\n            },\n            is_execution_request: fields[160] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                args_hash: fields[12],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    pub fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context {\n            private: Option::some(context),\n            public: Option::none()\n        }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context {\n            public: Option::some(context),\n            private: Option::none()\n        }\n    }\n\n    pub fn none() -> Context {\n        Context {\n            public: Option::none(),\n            private: Option::none()\n        }\n    }\n}",
        "path": "/aztec/context.nr"
      },
      "41": {
        "source": "use dep::std::hash::{pedersen_hash_with_separator, sha256};\nuse crate::constants_gen::{\n  GENERATOR_INDEX__SIGNATURE_PAYLOAD,\n  GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET,\n};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n  let sha256_hashed = sha256(bytes_to_hash);\n\n  // Convert it to a field element\n  let mut v = 1;\n  let mut high = 0 as Field;\n  let mut low = 0 as Field;\n\n  for i in 0..16 {\n      high = high + (sha256_hashed[15 - i] as Field) * v;\n      low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n      v = v * 256;\n  }\n\n  // Abuse that a % p + b % p = (a + b) % p and that low < p\n  let hash_in_a_field = low + high * v;\n\n  hash_in_a_field\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n  // TODO(#1205) This is probably not the right index to use\n  pedersen_hash([secret], GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET)\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n  pedersen_hash_with_separator(inputs, hash_index)\n}",
        "path": "/aztec/hash.nr"
      },
      "42": {
        "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse crate::types::point::Point;\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    log: [Field; N],\n) {\n    let _ = oracle::logs::emit_encrypted_log(contract_address, storage_slot, encryption_pub_key, log);\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(\n    context: &mut PublicContext,\n    log: T,\n) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(\n    context: &mut PrivateContext,\n    log: T,\n) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n",
        "path": "/aztec/log.nr"
      },
      "47": {
        "source": "use crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\nuse crate::constants_gen::EMPTY_NULLIFIED_COMMITMENT;\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n    broadcast: bool,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialize = note_interface.serialize;\n    let serialized_note = serialize(*note);\n    assert(notify_created_note(storage_slot, serialized_note, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        let broadcast = note_interface.broadcast;\n        broadcast(context, storage_slot, *note);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = EMPTY_NULLIFIED_COMMITMENT;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(nullifier, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}",
        "path": "/aztec/note/lifecycle.nr"
      },
      "48": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address == contract_address);\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(\n    fields: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        assert(fields[select.field_index] == select.value, \"Mismatch return note field.\");\n    }\n}\n\nfn check_notes_order<N>(fields_0: [Field; N], fields_1: [Field; N], sorts: BoundedVec<Option<Sort>, N>) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index] as u120 < fields_1[sort.field_index] as u120;\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let serialize = note_interface.serialize;\n            let fields = serialize(note);\n            check_note_header(*context, storage_slot, note_interface, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    };\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields,\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteViewerOptions<Note, N>,\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    };\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    };\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}",
        "path": "/aztec/note/note_getter.nr"
      },
      "50": {
        "source": "use crate::hash::pedersen_hash;\nuse crate::constants_gen::{GENERATOR_INDEX__UNIQUE_COMMITMENT, GENERATOR_INDEX__SILOED_COMMITMENT};\n\npub fn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([storage_slot, note_hash], 0)\n}\n\npub fn compute_siloed_hash(contract_address: Field, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)\n}\n\npub fn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)\n}\n",
        "path": "/aztec/note/note_hash.nr"
      },
      "54": {
        "source": "use crate::note::{\n    note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\npub fn compute_inner_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\npub fn compute_unique_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_note_hash_for_read_or_nullify<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386)\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n\n}\n\npub fn compute_note_hash_and_nullifier<Note, N, S>(\n    note_interface: NoteInterface<Note, N>,\n    note_header: NoteHeader,\n    serialized_note: [Field; S],\n) -> [Field; 4] {\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    let mut note = deserialize(arr_copy_slice(serialized_note, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
        "path": "/aztec/note/utils.nr"
      },
      "61": {
        "source": "use crate::types::point::Point;\nuse crate::address::compute_address;\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: Field) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: Field) -> [Field; 3] {\n  get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: Field) -> Point {\n  let result = get_public_key_and_partial_address_internal(address);\n  let pub_key_x = result[0];\n  let pub_key_y = result[1];\n  let partial_address = result[2];\n  \n  let calculated_address = compute_address(pub_key_x, pub_key_y, partial_address);\n  assert(calculated_address == address);\n  \n  Point::new(pub_key_x, pub_key_y)\n}\n",
        "path": "/aztec/oracle/get_public_key.nr"
      },
      "62": {
        "source": "use crate::oracle::get_public_key::get_public_key;\nuse crate::types::point::Point;\n\n#[oracle(getSecretKey)]\nfn get_secret_key_oracle(\n    _owner: Point,\n) -> [Field; dep::std::grumpkin_scalar::GRUMPKIN_SCALAR_SERIALIZED_LEN] {\n}\n\nunconstrained fn get_secret_key_internal(owner_public_key: Point) -> dep::std::grumpkin_scalar::GrumpkinScalar {\n    dep::std::grumpkin_scalar::deserialize_grumpkin_scalar(get_secret_key_oracle(owner_public_key))\n}\n\npub fn get_secret_key(owner: Field) -> dep::std::grumpkin_scalar::GrumpkinScalar {\n    let owner_public_key = get_public_key(owner);\n    let secret = get_secret_key_internal(owner_public_key);\n\n    // Constrain the owner - Nullifier secret key is currently just the encryption private key so we can constrain\n    // the owner by deriving the public key from the secret key and checking the result.\n    let computed_public_key = dep::std::grumpkin_scalar_mul::grumpkin_fixed_base(secret);\n    assert(owner_public_key.x == computed_public_key[0]);\n    assert(owner_public_key.y == computed_public_key[1]);\n\n    secret\n}\n",
        "path": "/aztec/oracle/get_secret_key.nr"
      },
      "63": {
        "source": "\n\n#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n",
        "path": "/aztec/oracle/rand.nr"
      },
      "66": {
        "source": "use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field,\n) -> Field {\n    notify_created_note_oracle(storage_slot, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(\n    _nullifier: Field,\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(\n    nullifier: Field,\n    inner_note_hash: Field,\n) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    mut placeholder_fields: [Field; S],\n)-> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, return_size, placeholder_fields)\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n) -> [Option<Note>; S] {\n    let fields = get_notes_oracle_wrapper(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, placeholder_fields);\n    let num_notes = fields[0] as u32;\n    let contract_address = fields[1];\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_transient.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = deserialize(serialized_note);\n            set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    };\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(\n    _inner_nullifier: Field,\n) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}",
        "path": "/aztec/oracle/notes.nr"
      },
      "68": {
        "source": "use crate::types::point::Point;\nuse crate::constants_gen::NUM_FIELDS_PER_SHA256;\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: Field,\n    _storage_slot: Field,\n    _encryption_pub_key: Point,\n    _preimage: [Field; N],\n)  -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    preimage: [Field; N],\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [emit_encrypted_log_oracle(\n        contract_address,\n        storage_slot,\n        encryption_pub_key,\n        preimage,\n    ), 0]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(_contract_address: Field, _event_selector: Field, _message: T)  -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(contract_address: Field, event_selector: Field, message: T) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}",
        "path": "/aztec/oracle/logs.nr"
      },
      "74": {
        "source": "use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::std::option::Option;\nuse crate::hash::pedersen_hash;\n\n// docs:start:map\nstruct Map<V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<V> Map<V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Map<V> {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map {\n            context,\n            storage_slot,\n            state_var_constructor,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: Field) -> V {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key],0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n",
        "path": "/aztec/state_vars/map.nr"
      },
      "76": {
        "source": "use dep::std::option::Option;\nuse crate::abi::PublicContextInputs;\nuse crate::constants_gen::{MAX_NOTES_PER_PAGE, MAX_READ_REQUESTS_PER_CALL};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\n\n// docs:start:struct\nstruct Set<Note, N> {\n    context: Context,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n}\n// docs:end:struct\n\nimpl<Note, N> Set<Note, N> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        note_interface: NoteInterface<Note, N>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Set {\n            context,\n            storage_slot,\n            note_interface,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:insert\n    pub fn insert(self,\n        note: &mut Note,\n        broadcast: bool,\n    ) {\n        create_note(\n            self.context.private.unwrap(),\n            self.storage_slot,\n            note,\n            self.note_interface,\n            broadcast,\n        );\n    }\n    // docs:end:insert\n\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(\n            self.context.public.unwrap(),\n            self.storage_slot,\n            note,\n            self.note_interface,\n        );\n    }\n    // docs:end:insert_from_public\n    \n    // DEPRECATED\n    fn assert_contains_and_remove(_self: Self, _note: &mut Note, _nonce: Field) {\n        assert(false, \"`assert_contains_and_remove` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use Set.get_notes() and Set.remove() in your contract to verify and remove a note.\");\n    }\n\n    // DEPRECATED\n    fn assert_contains_and_remove_publicly_created(_self: Self, _note: &mut Note) {\n        assert(false, \"`assert_contains_and_remove_publicly_created` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use Set.get_notes() and Set.remove() in your contract to verify and remove a note.\");\n    }\n\n    // docs:start:remove\n    pub fn remove(self, note: Note) {\n        let context = self.context.private.unwrap();\n        let note_hash = compute_note_hash_for_read_or_nullify(self.note_interface, note);\n        let has_been_read = context.read_requests.any(|r| r == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(\n            context,\n            note,\n            self.note_interface,\n        );\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n    ) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n        let storage_slot = self.storage_slot;\n        let opt_notes = get_notes(\n            self.context.private.unwrap(),\n            storage_slot,\n            self.note_interface,\n            options,\n        );\n        opt_notes\n    }\n    // docs:end:get_notes\n\n    // docs:start:view_notes\n    unconstrained pub fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n        view_notes(self.storage_slot, self.note_interface, options)\n    }\n    // docs:end:view_notes\n}\n",
        "path": "/aztec/state_vars/set.nr"
      },
      "81": {
        "source": "\nstruct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: Field) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n\n#[test]\nfn test_vec_push_pop() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    assert(vec.len == 0);\n    vec.push(2);\n    assert(vec.len == 1);\n    vec.push(4);\n    assert(vec.len == 2);\n    vec.push(6);\n    assert(vec.len == 3);\n    let x = vec.pop();\n    assert(x == 6);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test]\nfn test_vec_push_array() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test(should_fail)]\nfn test_vec_get_out_of_bound() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    let _x = vec.get(2);\n}\n\n#[test(should_fail)]\nfn test_vec_get_not_declared() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2]);\n    let _x = vec.get(1);\n}\n\n#[test(should_fail)]\nfn test_vec_get_uninitialized() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    let _x = vec.get(0);\n}\n\n#[test(should_fail)]\nfn test_vec_push_overflow() {\n    let mut vec: BoundedVec<Field, 1> = BoundedVec::new(0);\n    vec.push(1);\n    vec.push(2);\n}\n\n#[test]\nfn test_vec_any() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4, 6]);\n    assert(vec.any(|v| v == 2) == true);\n    assert(vec.any(|v| v == 4) == true);\n    assert(vec.any(|v| v == 6) == true);\n    assert(vec.any(|v| v == 3) == false);\n}\n\n#[test]\nfn test_vec_any_not_default() {\n    let default_value = 1;\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(default_value);\n    vec.push_array([2, 4]);\n    assert(vec.any(|v| v == default_value) == false);\n}",
        "path": "/aztec/types/vec.nr"
      },
      "87": {
        "source": "pub fn arr_copy_slice<T, N, M>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: Field,\n) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n\npub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() as u32 < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}",
        "path": "/aztec/utils.nr"
      },
      "88": {
        "source": "use dep::aztec::note::{\n    note_getter::view_notes,\n    note_viewer_options::NoteViewerOptions,\n};\nuse dep::aztec::state_vars::set::Set;\nuse crate::value_note::{VALUE_NOTE_LEN, ValueNote};\n\nunconstrained pub fn get_balance(set: Set<ValueNote, VALUE_NOTE_LEN>) -> Field {\n    get_balance_with_offset(set, 0)\n}\n\nunconstrained pub fn get_balance_with_offset(set: Set<ValueNote, VALUE_NOTE_LEN>, offset: u32) -> Field {\n    let mut balance = 0;\n    // docs:start:view_notes\n    let options = NoteViewerOptions::new().set_offset(offset);\n    let opt_notes = set.view_notes(options);\n    // docs:end:view_notes\n    let len = opt_notes.len();\n    for i in 0..len {\n        if opt_notes[i].is_some() {\n            balance += opt_notes[i].unwrap_unchecked().value;\n        }\n    }\n    if (opt_notes[len - 1].is_some()) {\n        balance += get_balance_with_offset(set, offset + opt_notes.len() as u32);\n    }\n\n    balance\n}",
        "path": "/value_note/balance_utils.nr"
      },
      "91": {
        "source": "use dep::aztec::{\n    note::{\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n        utils::compute_note_hash_for_read_or_nullify,\n    },\n    oracle::{\n        rand::rand,\n        get_secret_key::get_secret_key,\n        get_public_key::get_public_key,\n    },\n    log::emit_encrypted_log,\n    hash::pedersen_hash,\n    context::PrivateContext,\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\nstruct ValueNote {\n    value: Field,\n    owner: Field,\n    randomness: Field,\n    header: NoteHeader,\n}\n// docs:end:value-note-def\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: Field) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote {\n            value,\n            owner,\n            randomness,\n            header,\n        }\n    }\n\n    pub fn serialize(self) -> [Field; VALUE_NOTE_LEN] {\n        [self.value, self.owner, self.randomness]\n    }\n\n    pub fn deserialize(serialized_note: [Field; VALUE_NOTE_LEN]) -> Self {\n        ValueNote {\n            value: serialized_note[0],\n            owner: serialized_note[1],\n            randomness: serialized_note[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    pub fn compute_note_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize(),0)\n    }\n\n    // docs:start:nullifier\n\n    pub fn compute_nullifier(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_read_or_nullify(ValueNoteMethods, self);\n        let secret = get_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    pub fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    pub fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            encryption_pub_key,\n            self.serialize(),\n        );\n    }\n}\n\nfn deserialize(serialized_note: [Field; VALUE_NOTE_LEN]) -> ValueNote {\n    ValueNote::deserialize(serialized_note)\n}\n\nfn serialize(note: ValueNote) -> [Field; VALUE_NOTE_LEN] {\n    note.serialize()\n}\n\nfn compute_note_hash(note: ValueNote) -> Field {\n    note.compute_note_hash()\n}\n\nfn compute_nullifier(note: ValueNote) -> Field {\n    note.compute_nullifier()\n}\n\nfn get_header(note: ValueNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut ValueNote, header: NoteHeader) {\n    note.set_header(header)\n}\n\n// Broadcasts the note as an encrypted log on L1.\nfn broadcast(context: &mut PrivateContext, slot: Field, note: ValueNote) {\n    note.broadcast(context, slot);\n}\n\nglobal ValueNoteMethods = NoteInterface {\n    deserialize,\n    serialize,\n    compute_note_hash,\n    compute_nullifier,\n    get_header,\n    set_header,\n    broadcast,\n};\n",
        "path": "/value_note/value_note.nr"
      },
      "92": {
        "source": "use dep::aztec::{\n    context::Context,\n    note::note_getter_options::NoteGetterOptions,\n    state_vars::set::Set,\n};\nuse dep::value_note::{\n    filter::filter_notes_min_sum,\n    value_note::{ValueNote, ValueNoteMethods, VALUE_NOTE_LEN},\n};\n\nstruct EasyPrivateUint {\n    context: Context,\n    set: Set<ValueNote, VALUE_NOTE_LEN>,\n    storage_slot: Field,\n}\n\nimpl EasyPrivateUint {\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        let set = Set {\n            context,\n            storage_slot,\n            note_interface: ValueNoteMethods,\n        };\n        EasyPrivateUint {\n            context,\n            set,\n            storage_slot,\n        }\n    }\n\n    // Very similar to `value_note::utils::increment`.\n    pub fn add(self, addend: u120, owner: Field) {\n        // Creates new note for the owner.\n        let mut addend_note = ValueNote::new(addend as Field, owner);\n\n        // Insert the new note to the owner's set of notes.\n        // docs:start:insert\n        self.set.insert(&mut addend_note, true);\n        // docs:end:insert\n    }\n\n    // Very similar to `value_note::utils::decrement`.\n    pub fn sub(self, subtrahend: u120, owner: Field) {\n        // docs:start:get_notes\n        let options = NoteGetterOptions::with_filter(filter_notes_min_sum, subtrahend as Field);\n        let maybe_notes = self.set.get_notes(options);\n        // docs:end:get_notes\n\n        let mut minuend: u120 = 0;\n        for i in 0..maybe_notes.len() {\n            if maybe_notes[i].is_some() {\n                let note = maybe_notes[i].unwrap_unchecked();\n\n                // Ensure the notes are actually owned by the owner (to prevent user from generating a valid proof while\n                // spending someone else's notes).\n                assert(note.owner == owner);\n\n                // Removes the note from the owner's set of notes.\n                // docs:start:remove\n                self.set.remove(note);\n                // docs:end:remove\n\n                minuend += note.value as u120;\n            }\n        }\n\n        assert(minuend >= subtrahend);\n\n        // Creates change note for the owner.\n        let result_value = minuend - subtrahend;\n        let mut result_note = ValueNote::new(result_value as Field, owner);\n        self.set.insert(&mut result_note, result_value != 0);\n    }\n}\n",
        "path": "/easy_private_state/easy_private_state.nr"
      }
    }
  },
  "aztecNrVersion": "aztec-packages-v0.14.2"
}